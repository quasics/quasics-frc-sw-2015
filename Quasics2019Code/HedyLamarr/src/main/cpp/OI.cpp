// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "OI.h"
#include "ControllerDefinitions.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/AutonomousCommand.h"
#include "Commands/TankDrive.h"
#include "frc/smartdashboard/SmartDashboard.h"

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/ElbowControl.h"
#include "Commands/IntakeControl.h"
#include "Commands/MoveToBottom.h"
#include "Commands/MoveToPositionOne.h"
#include "Commands/MoveToPositionTwo.h"
#include "Commands/MoveToTop.h"

OI::OI() {
  // Process operator interface input here.
  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
  operatorStick.reset(new frc::Joystick(1));

  driveStick.reset(new frc::Joystick(0));

  // SmartDashboard Buttons
  frc::SmartDashboard::PutData("Tank Drive", new TankDrive());
  frc::SmartDashboard::PutData("Autonomous Command", new AutonomousCommand());

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

  frc::SmartDashboard::PutData("Intake", new IntakeControl());
  frc::SmartDashboard::PutData("Elbow Control", new ElbowControl());

  TopElevatorButton.reset(
      new frc::JoystickButton(operatorStick.get(), XBox_LeftTrigger));
  TopElevatorButton->WhenPressed(new MoveToTop());

  BottomElevatorButton.reset(
      new frc::JoystickButton(operatorStick.get(), XBox_RightTrigger));
  BottomElevatorButton->WhenPressed(new MoveToBottom());

  PositionOneElevatorButton.reset(
      new frc::JoystickButton(operatorStick.get(), XBox_RightButton));
  PositionOneElevatorButton->WhenPressed(new MoveToPositionOne());

  PositionTwoElevatorButton.reset(
      new frc::JoystickButton(operatorStick.get(), XBox_LeftButton));
  PositionTwoElevatorButton->WhenPressed(new MoveToPositionTwo());
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

std::shared_ptr<frc::Joystick> OI::getDriveStick() {
  return driveStick;
}

std::shared_ptr<frc::Joystick> OI::getOperatorStick() {
  return operatorStick;
}

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

double OI::getLeftTankSpeed() {
  return driveStick->GetRawAxis(LogitechGamePad_LeftYAxis);
}

double OI::getRightTankSpeed() {
  return driveStick->GetRawAxis(LogitechGamePad_RightYAxis);
}

double OI::getElbowDirection() {
  return operatorStick->GetRawAxis(XBox_RightYAxis);
}

bool OI::isIntakeSignaledPositive() {  // in
  const bool buttonA = operatorStick->GetRawButton(XBox_ButtonA);
  return buttonA;
}

bool OI::isIntakeSignaledLowNegative() {  // out, slowly
  const bool buttonB = operatorStick->GetRawButton(XBox_ButtonB);
  return buttonB;
}

bool OI::isIntakeSignaledHighNegative() {  // out, quickly
  const bool buttonY = operatorStick->GetRawButton(XBox_ButtonY);
  return buttonY;
}

bool OI::isElbowSignaledUp() {
  const double direction = operatorStick->GetRawAxis(XBox_RightYAxis);
  if (direction > 0.3) {
    return true;
  } else {
    return false;
  }
}

bool OI::isElbowSignaledDown() {
  const double direction = operatorStick->GetRawAxis(XBox_RightYAxis);
  if (direction < -0.3) {
    return true;
  } else {
    return false;
  }
}

bool OI::isFullSpeedTriggered() {
  const bool RightTrigger =
      driveStick->GetRawButton(LogitechGamePad_RightTrigger);
  const bool LeftTrigger =
      driveStick->GetRawButton(LogitechGamePad_LeftTrigger);
  if (RightTrigger && LeftTrigger) {
    return true;
  } else {
    return false;
  }
}

bool OI::isTurtleTriggerDown() {
  const bool RightShoulder =
      driveStick->GetRawButton(LogitechGamePad_RightShoulder);
  return RightShoulder;
}

constexpr double kElevatorDeadZoneWidth = 0.3;

bool OI::isElevatorMoveUpSignaled() {
  const double joystick = operatorStick->GetRawAxis(XBox_LeftYAxis);
  if (joystick >= kElevatorDeadZoneWidth) {
    return true;
  } else {
    return false;
  }
}

bool OI::isElevatorMoveDownSignaled() {
  const double joystick = operatorStick->GetRawAxis(XBox_LeftYAxis);
  if (joystick <= -kElevatorDeadZoneWidth) {
    return true;
  } else {
    return false;
  }
}
