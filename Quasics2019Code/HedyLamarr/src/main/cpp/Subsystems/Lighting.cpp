// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Subsystems/Lighting.h"

#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <iostream>

// Arbitrary port that we'll need to agree on using with the Arduino.
// (Rio will send to this, Arduino will listen *on* this.)
constexpr unsigned short USE_PORT = 10900;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// Returns a reference to the socket, or -1 on failure.
int setupUdpSocket() {
  // Try to get a socket
  int sock;
  if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
    return -1;
  }
  int broadcast = 1; /* Note: on some platforms, this may need to be "char" */
  if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &broadcast,
                 sizeof broadcast) == -1) {
    ::close(sock);
    return -1;
  }
  return sock;
}

// Translates the string version of an IP address (plus a port number) into
// the underlying data format that's required when we send messages.
//
// This is used to build up the destination address that we'll be sending
// our commands to (which in our case is expected to be a "broadcast" address
// that any number of computers could be listening to, but in practice will
// just be the Arduino controlling our lights).
bool getDestinationAddress(sockaddr_in &result, std::string ipAddress,
                           unsigned short port) {
  memset((char *)&result, 0, sizeof(result));
  if (inet_aton(ipAddress.c_str(), &result.sin_addr) == 0) {
    return false;
  }
  result.sin_family = AF_INET;
  result.sin_port = htons(port);
  return true;
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Lighting::Lighting() : frc::Subsystem("Lighting"),  udpSocket(setupUdpSocket()) {
   if (udpSocket == -1) {
    // We weren't able to create/set up the socket.
    std::cerr
        << "***** Warning: Failed to allocate socket for Lighting subsystem!\n";
  } else if (!getDestinationAddress(broadcastAddress, "255.255.255.255",
                                    USE_PORT)) {
    std::cerr << "***** Warning: Failed to get broadcast address for Lighting "
                 "subsystem!\n";

    // If we don't know who to broadcast to, we might as well close up the
    // socket, since we won't be able to use it later.
    std::cerr << "               (Closing socket....)\n";
    ::close(udpSocket);
    udpSocket = -1;
  }
  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

// Destructor, used to clean up when the Subsystem goes away.
Lighting::~Lighting() {
  // Be polite, and close the socket now that we're done with it.
  if (udpSocket != -1) {
    ::close(udpSocket);
    udpSocket = -1;
  }
}
void Lighting::InitDefaultCommand() {
  // Set the default command for a subsystem here.
  // SetDefaultCommand(new MySpecialCommand());

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Lighting::Periodic() {
  // Put code here to be run every loop
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

// Put methods for controlling this subsystem
// here. Call these from Commands.
 
// Sends the specified command out (via broadcast) to the Arduino.
bool Lighting::sendCommandToArduino(const std::string &cmd) {
  if (udpSocket == -1) {
    std::cerr << "Warning: Can't send '" << cmd << "' to Arduino (no socket)\n";
    return false;
  }

  const int bytesToSend = cmd.length() + 1;
  return (sendto(udpSocket, cmd.c_str(), bytesToSend, 0,
                 reinterpret_cast<const sockaddr *>(&broadcastAddress),
                 sizeof(broadcastAddress)) == bytesToSend);
}
