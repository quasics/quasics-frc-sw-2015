// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "TankDrive.h"

#include <Commands/Subsystem.h>
#include "../Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

TankDrive::TankDrive() :
    Command() {
    // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    Requires(Robot::driveSystem.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void TankDrive::Initialize() {

}

enum SpeedMode {
    eSlow = 0, eMedium = 1, eFast = 2
};
static const double ScalingFactors[][2] = {
// First is left motor scaling; second is right
    { .25, .25 },       // slow
    { .5, .5 },     // medium
    { .75, .75 }    // fast
};

const double kMinPowerSetting = -.2;
const double kMaxPowerSetting = .2;

// Called repeatedly when this Command is scheduled to run
void TankDrive::Execute() {
#define USE_SLIDER_FOR_TRIM
#ifdef USE_SLIDER_FOR_TRIM

    if (SmartDashboard::GetNumber("Left Trim", 0) > .5) {
        SmartDashboard::PutNumber("Left Trim", .5);
    }
    else if (SmartDashboard::GetNumber("Left Trim", 0) < -.5) {
        SmartDashboard::PutNumber("Left Trim", -.5);
    }

    if (SmartDashboard::GetNumber("Right Trim", 0) > .5) {
        SmartDashboard::PutNumber("Right Trim", .5);
    }
    else if (SmartDashboard::GetNumber("Right Trim", 0) < -.5) {
        SmartDashboard::PutNumber("Right Trim", -.5);
    }

    const double leftSliderValue = SmartDashboard::GetNumber("Left Trim", 0)
                                   + 1;
    const double rightSliderValue = SmartDashboard::GetNumber("Right Trim", 0)
                                    + 1;

    SpeedMode mode = eSlow;
    if ((Robot::oi->getPilotStick()->GetRawButton(5)
            || Robot::oi->getPilotStick()->GetRawButton(6))
            && !(Robot::oi->getPilotStick()->GetRawButton(7)
                 || Robot::oi->getPilotStick()->GetRawButton(8))) {
        mode = eSlow;
    }
    else if (!(Robot::oi->getPilotStick()->GetRawButton(5)
               || Robot::oi->getPilotStick()->GetRawButton(6))
             && (Robot::oi->getPilotStick()->GetRawButton(7)
                 || Robot::oi->getPilotStick()->GetRawButton(8))) {
        mode = eFast;
    }
    else {
        mode = eMedium;
    }

    const double leftFactor = ScalingFactors[int(mode)][0];
    const double rightFactor = ScalingFactors[int(mode)][1];

    float leftStick = 0;
    float rightStick = 0;

    if (fabs(Robot::oi->getPilotStick()->GetRawAxis(1)) >= .05) {
        leftStick = Robot::oi->getPilotStick()->GetRawAxis(1);
    }
    else {
        leftStick = 0;
    }

    if (fabs(Robot::oi->getPilotStick()->GetRawAxis(3)) >= .05) {
        rightStick = Robot::oi->getPilotStick()->GetRawAxis(3);
    }
    else {
        rightStick = 0;
    }

    Robot::driveSystem->MoveLeft(-leftStick * leftSliderValue
                                 * leftFactor * 100);
    Robot::driveSystem->MoveRight(-rightStick * rightSliderValue
                                  * rightFactor * 100);

#else
    // Figure out what mode the driver wants
    SpeedMode mode = eSlow;
    if ((Robot::oi->getPilotStick()->GetRawButton(5)
            || Robot::oi->getPilotStick()->GetRawButton(6))
            && !(Robot::oi->getPilotStick()->GetRawButton(7)
                 || Robot::oi->getPilotStick()->GetRawButton(8))) {
        mode = eSlow;
    }
    else if (!(Robot::oi->getPilotStick()->GetRawButton(5)
               || Robot::oi->getPilotStick()->GetRawButton(6))
             && (Robot::oi->getPilotStick()->GetRawButton(7)
                 || Robot::oi->getPilotStick()->GetRawButton(8))) {
        mode = eFast;
    }
    else {
        mode = eMedium;
    }

    float leftStick = 0;
    float rightStick = 0;

    if (fabs(Robot::oi->getPilotStick()->GetRawAxis(1)) >= .05) {
        leftStick = Robot::oi->getPilotStick()->GetRawAxis(1);
    }
    else {
        leftStick = 0;
    }

    if (fabs(Robot::oi->getPilotStick()->GetRawAxis(3)) >= .05) {
        rightStick = Robot::oi->getPilotStick()->GetRawAxis(3);
    }
    else {
        rightStick = 0;
    }

    // Set the drive speed, based on joystick position and speed mode.
    const double leftFactor = ScalingFactors[int(mode)][0];
    const double rightFactor = ScalingFactors[int(mode)][1];
    Robot::driveSystem->MoveLeft(
        -leftStick * leftFactor);
    Robot::driveSystem->MoveRight(
        -rightStick * rightFactor);
#endif
}

// Make this return true when this Command no longer needs to run execute()
bool TankDrive::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void TankDrive::End() {
    Robot::driveSystem->StopEverything();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TankDrive::Interrupted() {
    Robot::driveSystem->StopEverything();
}
