// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "IntakeArm.h"
#include "../RobotMap.h"
#include <iostream>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

IntakeArm::IntakeArm() :
    Subsystem("IntakeArm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftArm = RobotMap::intakeArmLeftArm;
    rightArm = RobotMap::intakeArmRightArm;
    leftArmEncoder = RobotMap::intakeArmLeftArmEncoder;
    rightArmEncoder = RobotMap::intakeArmRightArmEncoder;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    leftArmEncoder->SetDistancePerPulse(1);
    rightArmEncoder->SetDistancePerPulse(1);
    leftArmEncoder->Reset();
    rightArmEncoder->Reset();

    leftArm->SetInverted(false);
    rightArm->SetInverted(true);
}

void IntakeArm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

void IntakeArm::SetArmDirection(Direction whichDirection) {
    float rawPower = 0;
    switch (whichDirection) {
        case kRising:
            rawPower = .75;
            break;
        case kFalling:
            rawPower = -.75;
            break;
        default:
            rawPower = 0;
            break;
    }

    float leftRecovery = 0;
    float rightRecovery = 0;
    if (rawPower >= 0) {
        if (std::abs(leftArmEncoder->GetRaw() - rightArmEncoder->GetRaw())
                <= 5) {
            leftRecovery = 0;
            rightRecovery = 0;
        }
        else if (leftArmEncoder->Get() > rightArmEncoder->Get()) {
            leftRecovery = 0;
            rightRecovery = .5;
        }
        else {
            leftRecovery = .5;
            rightRecovery = 0;
        }
    }
    else {
        if (std::abs(leftArmEncoder->GetRaw() - rightArmEncoder->GetRaw())
                <= 5) {
            leftRecovery = 0;
            rightRecovery = 0;
        }
        else if (leftArmEncoder->Get() < rightArmEncoder->Get()) {
            leftRecovery = 0;
            rightRecovery = -.5;
        }
        else {
            leftRecovery = -.5;
            rightRecovery = 0;
        }
    }

    float leftMultiplier = 1;
    float rightMultiplier = 1;
    if (leftArmEncoder->GetRate() != 0 && rightArmEncoder->GetRate() != 0) {
        if (std::abs(leftArmEncoder->GetRate() - rightArmEncoder->GetRate())
                <= 5) {
            leftMultiplier = 1;
            rightMultiplier = 1;
        }
        else if (leftArmEncoder->GetRate() > rightArmEncoder->GetRate()) {
            leftMultiplier = rightArmEncoder->GetRate()
                             / leftArmEncoder->GetRate();
            rightMultiplier = 1;
        }
        else {
            leftMultiplier = 1;
            rightMultiplier = leftArmEncoder->GetRate()
                              / rightArmEncoder->GetRate();
        }
    }

    if (rawPower == 0) {
        leftArm->Set(leftRecovery);
        rightArm->Set(rightRecovery);
    }
    else {
        leftArm->Set(rawPower * leftMultiplier);
        rightArm->Set(rawPower * rightMultiplier);
    }
}

void IntakeArm::StopArm() {
    leftArm->Set(0);
    rightArm->Set(0);
}

void IntakeArm::DirectArmControll(float power) {
    float rawPower = -power;

    float leftRecovery = 0;
    float rightRecovery = 0;
    if (rawPower >= 0) {
        if (std::abs(leftArmEncoder->GetRaw() - rightArmEncoder->GetRaw())
                <= 5) {
            leftRecovery = 0;
            rightRecovery = 0;
        }
        else if (leftArmEncoder->Get() > rightArmEncoder->Get()) {
            leftRecovery = 0;
            rightRecovery = .25;
        }
        else {
            leftRecovery = .25;
            rightRecovery = 0;
        }
    }
    else {
        if (std::abs(leftArmEncoder->GetRaw() - rightArmEncoder->GetRaw())
                <= 5) {
            leftRecovery = 0;
            rightRecovery = 0;
        }
        else if (leftArmEncoder->Get() < rightArmEncoder->Get()) {
            leftRecovery = 0;
            rightRecovery = -.25;
        }
        else {
            leftRecovery = -.25;
            rightRecovery = 0;
        }
    }

    float leftMultiplier = 1;
    float rightMultiplier = 1;
    if (leftArmEncoder->GetRate() != 0 && rightArmEncoder->GetRate() != 0) {
        if (std::abs(leftArmEncoder->GetRate() - rightArmEncoder->GetRate())
                <= 5) {
            leftMultiplier = 1;
            rightMultiplier = 1;
        }
        else if (leftArmEncoder->GetRate() > rightArmEncoder->GetRate()) {
            leftMultiplier = rightArmEncoder->GetRate()
                             / leftArmEncoder->GetRate();
            rightMultiplier = 1;
        }
        else {
            leftMultiplier = 1;
            rightMultiplier = leftArmEncoder->GetRate()
                              / rightArmEncoder->GetRate();
        }
    }

    if (rawPower == 0) {
        leftArm->Set(leftRecovery);
        rightArm->Set(rightRecovery);
    }
    else {
        leftArm->Set(rawPower * leftMultiplier);
        rightArm->Set(rawPower * rightMultiplier);
    }
}
