// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Vision.h"
#include "../RobotMap.h"
#include <iostream>

#define IMG_WIDTH	320
#define IMG_HEIGHT	240

// Note: the following values mirror those that are currently hard-coded into MultipleOutputs.cpp,
// based on the GRIP pipeline configuration.  If we change the sizing in the pipeline,
// then we'll need to update the values here, too.
#define WIDTH_SCALING		.7
#define HEIGHT_SCALING		.7


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Vision::Vision() : frc::Subsystem("Vision") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

/*
 * The following code is based on an example provided at:
 * https://github.com/wpilibsuite/roboRIOVisionExamples/tree/master/2018/2018VisionSampleCPP
 *
 * It was then modified to:
 * a) Fix a bug on line 79 of the original code (where a "*" is missing).
* b) Look for the single largest bounding box, since the sample pipeline that
 *    we're currently using it with is trying to find one of the yellow game
 *    cubes, rather than looking for the 2 reflective tape stripes marking a
 *    point on the Switch in the 2018 FRC game.
 */
void Vision::startVisionTask() {
	cs::UsbCamera camera = frc::CameraServer::GetInstance()->StartAutomaticCapture();
	camera.SetResolution(IMG_WIDTH, IMG_HEIGHT);
	lock_ = new std::mutex;

	visionTrackingTask_ = new frc::VisionRunner<grip::MultipleOutputs>(
			camera, new grip::MultipleOutputs(),
			[&](grip::MultipleOutputs& pipeline) { processVisionPipeline(pipeline); }
		);
	visionThread_ = new std::thread(&Vision::visionExecuter, this);
}

void Vision::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Vision::Periodic() {
    // Put code here to be run every loop
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

void Vision::visionExecuter()
{
	std::cerr << "Starting up vision execution" << std::endl;
	assert(visionTrackingTask_ != nullptr);
	visionTrackingTask_->RunForever();
}

void Vision::processVisionPipeline(grip::MultipleOutputs& pipeline) {
	//
	// Part 1: Remember how big the source image was.
	BoundingRects boundingRects;
	boundingRects.imageRect.x = 0;
	boundingRects.imageRect.y = 0;
	boundingRects.imageRect.width = IMG_WIDTH * WIDTH_SCALING;
	boundingRects.imageRect.height = IMG_HEIGHT * HEIGHT_SCALING;

	//
	// Part 3: If we have at least 2 green contours, we might have a vision target in view

	// TODO(mjh): Write this section.


	//
	// Part 3: If we have at least 1 yellow contour, we might have a cube in view
	const auto & filterCubeCountoursOutput = *pipeline.GetFilterContours1Output();
	if (filterCubeCountoursOutput.size() > 0)
	{
		int bestArea = 0;
		//Iterate through list of found contours, and find the biggest one.
		for(unsigned int i=0; i < filterCubeCountoursOutput.size(); i++)
		{
			const std::vector<cv::Point> & countourPoints = filterCubeCountoursOutput[i];
			const cv::Rect rectangle1 = cv::boundingRect(cv::Mat(countourPoints));
			const int area = rectangle1.width * rectangle1.height;
			if (area > bestArea) {
				bestArea = area;
				boundingRects.cubeRect = rectangle1;
			}
		}
	}

	//
	// Part 4: Save the results.
	lock_->lock();
	boundingRects_ = boundingRects;
	lock_->unlock();
}
