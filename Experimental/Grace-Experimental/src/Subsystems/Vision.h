// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef VISION_H
#define VISION_H

#include "MultipleOutputs.h"

// Standard library stuff
#include <mutex>
#include <thread>
#include <memory>

// WPI-related includes
#include <WPILib.h>
#include <Commands/Subsystem.h>
#include <vision/VisionRunner.h>

/**
 *
 *
 * @author ExampleAuthor
 */
class Vision: public frc::Subsystem {
public:
	Vision();

	void visionExecuter();

	void InitDefaultCommand() override;
	void Periodic() override;

	// Defines the current set of bounding rects (for the image as a whole, for
	// the region containing the "current best" target area, and for the region
	// containing what we think is most likely to be a cube).
	struct BoundingRects {
		cv::Rect imageRect;
		cv::Rect cubeRect;
		cv::Rect targetRect;
	};

	void getBoundingRects(BoundingRects & result) const {
		lock_->lock();
		result = boundingRects_;
		lock_->unlock();
	}

	////////////////////////////////////////////////////////////////////////
	// Convenience functions (much less efficient, but possibly useful)
	cv::Rect getTargetRect() const {
		BoundingRects boundingRects;
		getBoundingRects(boundingRects);
		return boundingRects.targetRect;
	}
	cv::Rect getImageRect() const {
		BoundingRects boundingRects;
		getBoundingRects(boundingRects);
		return boundingRects.imageRect;
	}
	cv::Rect getCubeRect() const {
		BoundingRects boundingRects;
		getBoundingRects(boundingRects);
		return boundingRects.cubeRect;
	}

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

private:
	void startVisionTask();
	void processVisionPipeline(grip::MultipleOutputs& pipeline);
	void processNetworkDataFromGrip(BoundingRects& rects);

private:
	frc::VisionRunner<grip::MultipleOutputs> * visionTrackingTask_ = nullptr;
	BoundingRects boundingRects_;
	mutable std::mutex* lock_ = nullptr;			// Explicitly leaked
	std::thread* visionThread_ = nullptr;		// Explicitly leaked

	// Network table we'll use to get data from GRIP.
	std::shared_ptr<nt::NetworkTable> table;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

private:
	///////////////////////////////////////////////////////////////////////////
	/*
	 * The following scoring code is based on an example provided at:
	 * https://github.com/wpilibsuite/roboRIOVisionExamples/tree/master/2018/2018VisionSampleCPP
	 */
	/**
	 * Helper class to compute the outer dimensions of the rectangle that contains 2 OpenCV Rects.
	 */
	class BoundingRectHelper;

	double ratioToScore(double ratio);
	double boundingRatioScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds);
	double contourWidthScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds);
	double topEdgeScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds);
	double leftSpacingScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds);
	double widthRatioScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds);
	double heightRatioScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds);
	///////////////////////////////////////////////////////////////////////////
};

#endif
