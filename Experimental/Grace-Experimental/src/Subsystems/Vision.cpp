// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Vision.h"
#include "../RobotMap.h"
#include <iostream>

#define IMG_WIDTH	320
#define IMG_HEIGHT	240

// Note: the following values mirror those that are currently hard-coded into MultipleOutputs.cpp,
// based on the GRIP pipeline configuration.  If we change the sizing in the pipeline,
// then we'll need to update the values here, too.
#define WIDTH_SCALING		.7
#define HEIGHT_SCALING		.7


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Vision::Vision() : frc::Subsystem("Vision") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Vision::startVisionTask() {
	cs::UsbCamera camera = frc::CameraServer::GetInstance()->StartAutomaticCapture();
	camera.SetResolution(IMG_WIDTH, IMG_HEIGHT);
	lock_ = new std::mutex;

	visionTrackingTask_ = new frc::VisionRunner<grip::MultipleOutputs>(
			camera, new grip::MultipleOutputs(),
			[&](grip::MultipleOutputs& pipeline) { processVisionPipeline(pipeline); }
		);
	visionThread_ = new std::thread(&Vision::visionExecuter, this);
}

void Vision::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Vision::Periodic() {
    // Put code here to be run every loop
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

void Vision::visionExecuter()
{
	std::cerr << "Starting up vision execution" << std::endl;
	assert(visionTrackingTask_ != nullptr);
	visionTrackingTask_->RunForever();
}

/*
 * The following scoring code is based on an example provided at:
 * https://github.com/wpilibsuite/roboRIOVisionExamples/tree/master/2018/2018VisionSampleCPP
 */
namespace {
	/**
	 * Helper class to compute the outer dimensions of the rectangle that contains 2 OpenCV Rects.
	 */
	class BoundingRectHelper {
		public:
			int top = 0;
			int bottom = 0;
			int left = 0;
			int right = 0;

			BoundingRectHelper (const cv::Rect& rectangle1, const cv::Rect& rectangle2) {
				top = std::max(rectangle1.y, rectangle2.y);
				bottom = std::max(rectangle1.y + rectangle1.height, rectangle2.y + rectangle2.height);
				left = std::max(rectangle1.x, rectangle2.x);
				right = std::max(rectangle1.x + rectangle1.width, rectangle2.x + rectangle2.width);
			}
	};

	/**
	 * Converts a ratio with ideal value of 1 to a score. The resulting function is piecewise
	 * linear going from (0,0) to (1,100) to (2,0) and is 0 for all inputs outside the range 0-2
	 */
	double ratioToScore(double ratio) {
		return (std::max(0.0, std::min(100*(1-std::abs(1-ratio)), 100.0)));
	}

	// The height of the bounding box around both rectangles should be approximately double the width
	double boundingRatioScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds) {
		return ratioToScore((bounds.top - bounds.bottom)/(2*(bounds.left - bounds.right)));
	}

	// The width of either contour should be approximately 1/4 of the total bounding box width
	double contourWidthScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds) {
		return ratioToScore(rectangle1.width*4/(bounds.right-bounds.left));
	}

	// The top edges should be very close together. Find the difference, then scale it by the
	// bounding box height. This results in an ideal 0 instead of an ideal 1, so add 1
	double topEdgeScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds) {
		return ratioToScore(1 + (rectangle1.y - rectangle2.y)/(bounds.top-bounds.bottom));
	}

	// The spacing between the left edges should be 3/4 of the target width
	double leftSpacingScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds) {
		return ratioToScore(std::abs(rectangle2.x - rectangle1.x)*3/(4*bounds.right-bounds.left));
	}

	// The width of the two contours should match
	double widthRatioScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds) {
		return ratioToScore(rectangle1.width/rectangle2.width);
	}

	// The height of the two contours should match
	double heightRatioScore(const cv::Rect& rectangle1, const cv::Rect& rectangle2, const BoundingRectHelper& bounds) {
		return ratioToScore(rectangle1.height/rectangle2.height);
	}

}

void Vision::processVisionPipeline(grip::MultipleOutputs& pipeline) {
	//
	// Part 1: Remember how big the source image was.
	BoundingRects boundingRects;
	boundingRects.imageRect.x = 0;
	boundingRects.imageRect.y = 0;
	boundingRects.imageRect.width = IMG_WIDTH * WIDTH_SCALING;
	boundingRects.imageRect.height = IMG_HEIGHT * HEIGHT_SCALING;

	//
	// Part 3: If we have at least 2 green contours, we might have a vision target in view
	const auto & filterTargetCountoursOutput = *pipeline.GetFilterContours0Output();
	if (filterTargetCountoursOutput.size() > 0) {
		double bestScore = 0;
		// Iterate through list of found contours, and find the best-scoring pair.
		for(unsigned int i=0; i < filterTargetCountoursOutput.size(); i++) {
			const std::vector<cv::Point> & countour1Points = filterTargetCountoursOutput[i];
			const cv::Rect rectangle1 = cv::boundingRect(cv::Mat(countour1Points));

			// Try pairing rectangle # "i" with all of the ones that follow it.
			for (unsigned int j = i + 1; j < filterTargetCountoursOutput.size(); ++j ) {
				const std::vector<cv::Point> & countour2Points = filterTargetCountoursOutput[j];
				const cv::Rect rectangle2 = cv::boundingRect(cv::Mat(countour2Points));

				double scoreTotal = 0;
				BoundingRectHelper bounding(rectangle1, rectangle2);
				scoreTotal += boundingRatioScore(rectangle1, rectangle2, bounding);
				scoreTotal += contourWidthScore(rectangle1, rectangle2, bounding);
				scoreTotal += topEdgeScore(rectangle1, rectangle2, bounding);
				scoreTotal += leftSpacingScore(rectangle1, rectangle2, bounding);
				scoreTotal += widthRatioScore(rectangle1, rectangle2, bounding);
				scoreTotal += heightRatioScore(rectangle1, rectangle2, bounding);

				if (scoreTotal > bestScore) {
					scoreTotal = bestScore;
					BoundingRectHelper targetBounds(rectangle1, rectangle2);
					boundingRects.targetRect.x = targetBounds.top;
					boundingRects.targetRect.y = targetBounds.left;
					boundingRects.targetRect.width = targetBounds.bottom - targetBounds.top;
					boundingRects.targetRect.height = targetBounds.right - targetBounds.left;
				}
			}
		}
	}

	//
	// Part 3: If we have at least 1 yellow contour, we might have a cube in view
	const auto & filterCubeCountoursOutput = *pipeline.GetFilterContours1Output();
	if (filterCubeCountoursOutput.size() > 0) {
		int bestArea = 0;
		//Iterate through list of found contours, and find the biggest one.
		for(unsigned int i=0; i < filterCubeCountoursOutput.size(); i++) {
			const std::vector<cv::Point> & countourPoints = filterCubeCountoursOutput[i];
			const cv::Rect rectangle1 = cv::boundingRect(cv::Mat(countourPoints));
			const int area = rectangle1.width * rectangle1.height;
			if (area > bestArea) {
				bestArea = area;
				boundingRects.cubeRect = rectangle1;
			}
		}
	}

	//
	// Part 4: Save the results.
	lock_->lock();
	boundingRects_ = boundingRects;
	lock_->unlock();
}
