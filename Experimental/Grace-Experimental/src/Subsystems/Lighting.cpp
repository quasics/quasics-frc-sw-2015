// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Lighting.h"
#include "../RobotMap.h"
#include "../Commands/AutomaticLighting.h"
#include <iostream>

#include <DriverStation.h>
#include <RobotController.h>
#include <SerialPort.h>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Lighting::Lighting() : frc::Subsystem("Lighting") {
	serialPort_.reset(new frc::SerialPort(115200, frc::SerialPort::kMXP));
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	updateState();
}

void Lighting::InitDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new AutomaticLighting());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Lighting::Periodic() {
    // Put code here to be run every loop
}


void Lighting::updateState(bool force) {
	auto& driverStation = frc::DriverStation::GetInstance();

	auto ds_alliance = driverStation.GetAlliance();
	switch (ds_alliance) {
		case DriverStation::kRed:
			alliance_ = eRed;
			break;
		case DriverStation::kBlue:
			alliance_ = eBlue;
			break;
		case DriverStation::kInvalid:
			alliance_ = eDemo;
			break;
	}

	if (driverStation.IsAutonomous()) {
		mode_ = eAuto;
	} else if (driverStation.IsOperatorControl()) {
		mode_ = eTeleOp;
	} else if (driverStation.IsTest()) {
		mode_ = eTest;
	} else if (frc::RobotController::IsBrownedOut() || !frc::RobotController::IsSysActive()) {
		mode_ = eError;
	} else {
		mode_ = eIdle;
	}

	sendLightingCommand(force);
}

void Lighting::setAlliance(Alliance alliance) {
	this->alliance_ = alliance;
	sendLightingCommand(false);
}

void Lighting::setMode(Mode mode) {
	this->mode_ = mode;
	sendLightingCommand(false);
}

const char* const kLightMapping[3 /* alliance */][5 /* mode */] = {
				/* Idle */          /* Teleop */      /* Auto */       /* Error */        /* Test */
/* Red */		{"breathe-red\n",   "updown-red\n",   "chase-red\n",   "breath-yellow\n", "flash-red\n"},
/* Blue */		{"breathe-blue\n",  "updown-blue\n",  "chase-blue\n",  "breath-yellow\n", "flash-blue\n"},
/* Invalid */	{"breathe-green\n", "updown-green\n", "chase-green\n", "breath-yellow\n", "flash-green\n"},
};

// TODO: Determine what the commands to the Arduino will look like.
// The following code is based on some sample ideas, and the modes defined above.
void Lighting::sendLightingCommand(bool force) {
	const char * cmd = kLightMapping[alliance_][mode_];
	const bool canSendCommand = cmd && serialPort_;

	// Note that if we have a timeout on the Arduino (handling brownout, reset, etc.),
	// then we may want to force re-sending the command every so often, even if it has
	// not changed.
	const bool shouldSendCommand = (cmd != lastCommand_) || force;

	if (canSendCommand && shouldSendCommand) {
		std::cout << "Sending lighting command: " << cmd;
		serialPort_->Write(cmd);
		lastCommand_ = cmd;
	}
}

