// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "PortMappings.h"

#include <Drive/DifferentialDrive.h>
#include <Jaguar.h>
#include <Talon.h>
#include <PWMVictorSPX.h>
#include <SpeedController.h>
#include <SpeedControllerGroup.h>

#include <memory>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<frc::SpeedController> RobotMap::driveBaseFrontRight;
std::shared_ptr<frc::SpeedController> RobotMap::driveBaseBackRight;
std::shared_ptr<frc::SpeedControllerGroup> RobotMap::driveBaseRightMotors;
std::shared_ptr<frc::SpeedController> RobotMap::driveBaseFrontLeft;
std::shared_ptr<frc::SpeedController> RobotMap::driveBaseBackLeft;
std::shared_ptr<frc::SpeedControllerGroup> RobotMap::driveBaseLeftMotors;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

#define USE_TALONS_FOR_DRIVE_BASE
#ifdef USE_TALONS_FOR_DRIVE_BASE
// Used on Nike (2017 bot)
typedef frc::Talon				DriveMotorController;
#else
// Used on Katherine (2018 bot)
typedef frc::PWMVictorSPXTalon	DriveMotorController;
#endif

template<typename Widget>
void SetNameAndSubsystem(Widget& w, const char* subsystemName, const char* motorName) {
	w.SetName(subsystemName, motorName);
}
template<typename Motor>
std::shared_ptr<Motor> createMotor(int port, const char* subsystemName, const char* motorName) {
	std::unique_ptr<Motor> motor(new Motor(port));
	SetNameAndSubsystem(*motor, subsystemName, motorName);
	return std::shared_ptr<Motor>(motor.release());
}

void RobotMap::init() {
#ifdef USE_ROBOT_BUILDER_AUTOGEN_CODE
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

    driveBaseFrontRight.reset(new DriveMotorController(1));
    lw->AddActuator("DriveBase", "Front Right", std::static_pointer_cast<frc::Talon>(driveBaseFrontRight));
    
    driveBaseBackRight.reset(new DriveMotorController(0));
    lw->AddActuator("DriveBase", "Back Right", std::static_pointer_cast<frc::Talon>(driveBaseBackRight));
    
    driveBaseRightMotors = std::make_shared<frc::SpeedControllerGroup>(*driveBaseFrontRight, *driveBaseBackRight  );
    lw->AddActuator("DriveBase", "Right Motors", driveBaseRightMotors);
    
    driveBaseFrontLeft.reset(new DriveMotorController(2));
    lw->AddActuator("DriveBase", "Front Left", std::static_pointer_cast<frc::Talon>(driveBaseFrontLeft));
    
    driveBaseBackLeft.reset(new DriveMotorController(3));
    lw->AddActuator("DriveBase", "Back Left", std::static_pointer_cast<frc::Talon>(driveBaseBackLeft));
    
    driveBaseLeftMotors = std::make_shared<frc::SpeedControllerGroup>(*driveBaseFrontLeft, *driveBaseBackLeft  );
    lw->AddActuator("DriveBase", "Left Motors", driveBaseLeftMotors);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
#else
    driveBaseFrontRight = createMotor<DriveMotorController>(FRONT_RIGHT_MOTOR_PORT, "Drive Base", "frontRight");
    driveBaseBackRight = createMotor<DriveMotorController>(BACK_RIGHT_MOTOR_PORT, "Drive Base", "backRight");
    driveBaseFrontLeft = createMotor<DriveMotorController>(FRONT_LEFT_MOTOR_PORT, "Drive Base", "frontLeft");
    driveBaseBackLeft = createMotor<DriveMotorController>(BACK_LEFT_MOTOR_PORT, "Drive Base", "backLeft");

    driveBaseLeftMotors = std::make_shared<frc::SpeedControllerGroup>(*driveBaseFrontLeft, *driveBaseBackLeft  );
    SetNameAndSubsystem(*driveBaseLeftMotors, "DriveBase", "Left Motors");
    driveBaseRightMotors = std::make_shared<frc::SpeedControllerGroup>(*driveBaseFrontRight, *driveBaseBackRight  );
    SetNameAndSubsystem(*driveBaseLeftMotors, "DriveBase", "Left Motors");
#endif

    // The right-hand side motors are inverted on Nike.  (Which I'll assume we're building for.)
    driveBaseRightMotors->SetInverted(true);
}
