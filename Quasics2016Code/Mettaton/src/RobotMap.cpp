// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
#include "ThirdParty/NavX/include/AHRS.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<SpeedController> RobotMap::driveBaseLeftFront;
std::shared_ptr<SpeedController> RobotMap::driveBaseRightFront;
std::shared_ptr<SpeedController> RobotMap::driveBaseLeftRear;
std::shared_ptr<SpeedController> RobotMap::driveBaseRightRear;
std::shared_ptr<AHRS> RobotMap::driveBaseNavX;
std::shared_ptr<SpeedController> RobotMap::shooterArmLeftArm;
std::shared_ptr<SpeedController> RobotMap::shooterArmRightArm;
std::shared_ptr<Encoder> RobotMap::shooterArmLeftArmEncoder;
std::shared_ptr<Encoder> RobotMap::shooterArmRightArmEncoder;
std::shared_ptr<SpeedController> RobotMap::shooterLeftWheel;
std::shared_ptr<SpeedController> RobotMap::shooterRightWheel;
std::shared_ptr<DoubleSolenoid> RobotMap::shooterIntakePiston;
std::shared_ptr<SerialPort> RobotMap::lightingSerialPort;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    driveBaseLeftFront.reset(new Talon(0));
    lw->AddActuator("DriveBase", "LeftFront", std::static_pointer_cast<Talon>(driveBaseLeftFront));
    
    driveBaseRightFront.reset(new Talon(2));
    lw->AddActuator("DriveBase", "RightFront", std::static_pointer_cast<Talon>(driveBaseRightFront));
    
    driveBaseLeftRear.reset(new Talon(1));
    lw->AddActuator("DriveBase", "LeftRear", std::static_pointer_cast<Talon>(driveBaseLeftRear));
    
    driveBaseRightRear.reset(new Talon(3));
    lw->AddActuator("DriveBase", "RightRear", std::static_pointer_cast<Talon>(driveBaseRightRear));

    driveBaseNavX.reset(new AHRS(SPI::Port::kMXP));
    lw->AddSensor("DriveBase", "NavX", std::static_pointer_cast<AHRS>(driveBaseNavX));

    shooterArmLeftArm.reset(new Spark(6));
    lw->AddActuator("ShooterArm", "LeftArm", std::static_pointer_cast<Spark>(shooterArmLeftArm));
    
    shooterArmRightArm.reset(new Spark(7));
    shooterArmRightArm->SetInverted(true);
    lw->AddActuator("ShooterArm", "RightArm", std::static_pointer_cast<Spark>(shooterArmRightArm));
    
    shooterArmLeftArmEncoder.reset(new Encoder(4, 5, false, Encoder::k4X));
    lw->AddSensor("ShooterArm", "LeftArmEncoder", shooterArmLeftArmEncoder);
    shooterArmLeftArmEncoder->SetDistancePerPulse(12.8571428571);
    shooterArmLeftArmEncoder->SetPIDSourceType(PIDSourceType::kRate);
    shooterArmRightArmEncoder.reset(new Encoder(6, 7, true, Encoder::k4X));
    lw->AddSensor("ShooterArm", "RightArmEncoder", shooterArmRightArmEncoder);
    shooterArmRightArmEncoder->SetDistancePerPulse(12.8571428571);
    shooterArmRightArmEncoder->SetPIDSourceType(PIDSourceType::kRate);
    shooterLeftWheel.reset(new Victor(4));
    lw->AddActuator("Shooter", "LeftWheel", std::static_pointer_cast<Victor>(shooterLeftWheel));
    
    shooterRightWheel.reset(new Victor(5));
    lw->AddActuator("Shooter", "RightWheel", std::static_pointer_cast<Victor>(shooterRightWheel));
    
    shooterIntakePiston.reset(new DoubleSolenoid(1, 0, 1));
    lw->AddActuator("Shooter", "IntakePiston", shooterIntakePiston);
    
    lightingSerialPort.reset(new SerialPort(115200, SerialPort::kMXP));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
